import AppKit
import Combine

class ClipboardManager: ObservableObject {
    static let shared = ClipboardManager()
    
    @Published var items: [ClipboardItem] = []
    private var lastChangeCount = NSPasteboard.general.changeCount
    private var timer: Timer?
    
    // Hassas veri türleri (Şifre yöneticileri tarafından kullanılan standartlar)
    private let sensitiveTypes: [NSPasteboard.PasteboardType] = [
        .init("org.nspasteboard.ConcealedType"),     // 1Password, Bitwarden vb.
        .init("com.agilebits.onepassword"),          // Legacy 1Password
        .init("org.nspasteboard.AutoGeneratedType"), // Auto-generated passwords
        .init("com.typeit4me.clipping"),             // Text expansion tools
        .init("PASTEBOARD_TYPE_CONCEALED")           // Generic concealed
    ]
    
    private let storageKey = "whisprHistory"
    
    private init() {
        loadHistory()
        startMonitoring()
    }
    
    private func loadHistory() {
        if let data = UserDefaults.standard.data(forKey: storageKey),
           let decoded = try? JSONDecoder().decode([ClipboardItem].self, from: data) {
            self.items = decoded
        } else {
            // Default welcome items if no history exists
            addItem(content: "Welcome to Whispr! Copy any text to see it here.", type: .text, sourceApp: "Whispr")
            addItem(content: "Hover over items to see local AI actions like Clean or Summarize.", type: .text, sourceApp: "Whispr")
        }
    }
    
    private func saveHistory() {
        if let encoded = try? JSONEncoder().encode(items) {
            UserDefaults.standard.set(encoded, forKey: storageKey)
        }
    }
    
    func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            self?.checkClipboard()
        }
    }
    
    func checkClipboard() {
        let pasteboard = NSPasteboard.general
        
        // 1. Hassas veri kontrolü
        let hasSensitiveData = sensitiveTypes.first { pasteboard.types?.contains($0) ?? false } != nil
        if hasSensitiveData { return }
        
        guard pasteboard.changeCount != lastChangeCount else { return }
        lastChangeCount = pasteboard.changeCount
        
        if let content = pasteboard.string(forType: .string) {
            // Get source application info
            let sourceApp = NSWorkspace.shared.frontmostApplication?.localizedName
            
            if CreditCardUtils.isCreditCard(content) {
                addItem(content: content, type: .creditCard, sourceApp: sourceApp)
            } else {
                addItem(content: content, type: .text, sourceApp: sourceApp)
            }
        }
    }
    
    func addItem(content: String, type: ClipboardContentType, sourceApp: String? = nil) {
        let trimmedContent = content.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedContent.isEmpty else { return }

        DispatchQueue.main.async {
            var wasPinned = false
            if let existingIndex = self.items.firstIndex(where: { $0.content == trimmedContent }) {
                wasPinned = self.items[existingIndex].isPinned
                self.items.remove(at: existingIndex)
            }
            
            let newItem = ClipboardItem(
                content: trimmedContent,
                type: type,
                timestamp: Date(),
                sourceApp: sourceApp,
                isPinned: wasPinned
            )
            
            self.items.insert(newItem, at: 0)
            
            // 3. Re-sort to ensure pins stay at top
            self.items.sort { (a, b) in
                if a.isPinned != b.isPinned {
                    return a.isPinned
                }
                return a.timestamp > b.timestamp
            }
            
            // 4. Limit history size
            let historySize = UserDefaults.standard.integer(forKey: "historySize")
            let maxItems = historySize > 0 ? historySize : 50 // Default to 50 if not set
            
            if self.items.count > maxItems {
                self.items.removeLast(self.items.count - maxItems)
            }
            
            self.saveHistory()
            
            // Trigger Advanced AI Processing
            self.processItemAI(newItem.id)
        }
    }
    
    private func processItemAI(_ id: UUID) {
        guard let index = items.firstIndex(where: { $0.id == id }) else { return }
        let item = items[index]
        
        items[index].isProcessingAI = true
        
        Task {
            let result = await LLMService.shared.processAdvanced(item)
            
            await MainActor.run {
                if let currentIndex = self.items.firstIndex(where: { $0.id == id }) {
                    self.items[currentIndex].advancedAIResult = result
                    self.items[currentIndex].isProcessingAI = false
                    self.saveHistory()
                }
            }
        }
    }
    
    func performAIAction(_ item: ClipboardItem, action: LLMAction) {
        guard let index = items.firstIndex(where: { $0.id == item.id }) else { return }
        
        items[index].isProcessingAI = true
        
        Task {
            do {
                let result = try await LLMService.shared.process(item.content, action: action)
                await MainActor.run {
                    if let newIndex = self.items.firstIndex(where: { $0.id == item.id }) {
                        self.items[newIndex].aiResult = result
                        self.items[newIndex].isProcessingAI = false
                        self.saveHistory()
                    }
                }
            } catch {
                await MainActor.run {
                    if let newIndex = self.items.firstIndex(where: { $0.id == item.id }) {
                        self.items[newIndex].isProcessingAI = false
                        // Handle error state in UI
                    }
                }
            }
        }
    }
    
    func copyToClipboard(_ text: String) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(text, forType: .string)
    }
    
    func togglePin(for item: ClipboardItem) {
        guard let index = items.firstIndex(where: { $0.id == item.id }) else { return }
        
        let currentlyPinnedCount = items.filter { $0.isPinned }.count
        
        if !items[index].isPinned && currentlyPinnedCount >= 3 {
            // Optional: Show a notification or alert that max 3 pins are allowed
            return
        }
        
        items[index].isPinned.toggle()
        
        // Re-sort items: Pinned first, then by date
        items.sort { (a, b) in
            if a.isPinned != b.isPinned {
                return a.isPinned
            }
            return a.timestamp > b.timestamp
        }
        saveHistory()
    }
    
    func clearAIResult(for item: ClipboardItem) {
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            items[index].aiResult = nil
            saveHistory()
        }
    }
    
    func removeItem(_ item: ClipboardItem) {
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            items.remove(at: index)
            saveHistory()
        }
    }
    
    func clearAllHistory() {
        items.removeAll()
        saveHistory()
    }
}
