import AppKit
import Combine

class ClipboardManager: ObservableObject {
    static let shared = ClipboardManager()
    
    @Published var items: [ClipboardItem] = []
    private var lastChangeCount = NSPasteboard.general.changeCount
    private var timer: Timer?
    
    // Hassas veri türleri (Şifre yöneticileri tarafından kullanılan standartlar)
    private let sensitiveTypes: [NSPasteboard.PasteboardType] = [
        .init("org.nspasteboard.ConcealedType"),     // 1Password, Bitwarden vb.
        .init("com.agilebits.onepassword"),          // Legacy 1Password
        .init("org.nspasteboard.AutoGeneratedType"), // Auto-generated passwords
        .init("com.typeit4me.clipping"),             // Text expansion tools
        .init("PASTEBOARD_TYPE_CONCEALED")           // Generic concealed
    ]
    
    private let storageKey = "whisprHistory"
    private var desktopMonitor: DispatchSourceFileSystemObject?
    private var downloadsMonitor: DispatchSourceFileSystemObject?
    private var customMonitor: DispatchSourceFileSystemObject?
    private let fileManager = FileManager.default
    
    private init() {
        loadHistory()
        startMonitoring()
        refreshMonitors()
        
        NotificationCenter.default.addObserver(self, selector: #selector(refreshMonitors), name: .screenshotFolderChanged, object: nil)
    }
    
    @objc private func refreshMonitors() {
        stopMonitors()
        
        let customPath = UserDefaults.standard.string(forKey: "screenshotFolderPath") ?? ""
        
        if !customPath.isEmpty {
            startCustomMonitoring(path: customPath)
        } else {
            startDesktopMonitoring()
            startDownloadsMonitoring()
        }
    }
    
    private func stopMonitors() {
        desktopMonitor?.cancel()
        downloadsMonitor?.cancel()
        customMonitor?.cancel()
        desktopMonitor = nil
        downloadsMonitor = nil
        customMonitor = nil
    }
    
    private func startCustomMonitoring(path: String) {
        let url = URL(fileURLWithPath: path)
        let descriptor = open(url.path, O_EVTONLY)
        guard descriptor >= 0 else { return }
        
        customMonitor = DispatchSource.makeFileSystemObjectSource(fileDescriptor: descriptor, eventMask: .write, queue: .main)
        customMonitor?.setEventHandler { [weak self] in
            self?.checkNewScreenshots(at: url, groupName: "Screenshots (Custom)")
        }
        customMonitor?.setCancelHandler { close(descriptor) }
        customMonitor?.resume()
    }
    
    private func loadHistory() {
        if let data = UserDefaults.standard.data(forKey: storageKey),
           let decoded = try? JSONDecoder().decode([ClipboardItem].self, from: data) {
            self.items = decoded
        } else {
            // Default welcome items if no history exists
            addItem(content: "Welcome to Whispr! Copy any text to see it here.", type: .text, sourceApp: "Whispr")
            addItem(content: "Hover over items to see local AI actions like Clean or Summarize.", type: .text, sourceApp: "Whispr")
        }
    }
    
    private func saveHistory() {
        if let encoded = try? JSONEncoder().encode(items) {
            UserDefaults.standard.set(encoded, forKey: storageKey)
        }
    }
    
    private func startDesktopMonitoring() {
        let desktopPath = NSSearchPathForDirectoriesInDomains(.desktopDirectory, .userDomainMask, true).first!
        let desktopURL = URL(fileURLWithPath: desktopPath)
        
        let descriptor = open(desktopURL.path, O_EVTONLY)
        guard descriptor >= 0 else { return }
        
        desktopMonitor = DispatchSource.makeFileSystemObjectSource(fileDescriptor: descriptor, eventMask: .write, queue: .main)
        
        desktopMonitor?.setEventHandler { [weak self] in
            self?.checkNewScreenshots(at: desktopURL, groupName: "Screenshots (Desktop)")
        }
        
        desktopMonitor?.setCancelHandler {
            close(descriptor)
        }
        
        desktopMonitor?.resume()
    }
    
    private func startDownloadsMonitoring() {
        let downloadsPath = NSSearchPathForDirectoriesInDomains(.downloadsDirectory, .userDomainMask, true).first!
        let downloadsURL = URL(fileURLWithPath: downloadsPath)
        
        let descriptor = open(downloadsURL.path, O_EVTONLY)
        guard descriptor >= 0 else { return }
        
        downloadsMonitor = DispatchSource.makeFileSystemObjectSource(fileDescriptor: descriptor, eventMask: .write, queue: .main)
        
        downloadsMonitor?.setEventHandler { [weak self] in
            self?.checkNewScreenshots(at: downloadsURL, groupName: "Screenshots (Downloads)")
        }
        
        downloadsMonitor?.setCancelHandler {
            close(descriptor)
        }
        
        downloadsMonitor?.resume()
    }
    
    private func checkNewScreenshots(at url: URL, groupName: String) {
        // Give macOS a moment to finish writing the file
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
            guard let self = self else { return }
            do {
                let files = try self.fileManager.contentsOfDirectory(at: url, includingPropertiesForKeys: [.creationDateKey], options: .skipsHiddenFiles)
                
                let now = Date()
                let screenshots = files.filter { file in
                    let name = file.lastPathComponent
                    
                    let patterns = [
                        "Screenshot", "Screen Shot", "Ekran", "Captura", "Capture", 
                        "Bildschirmfoto", "Снимок", "Skjermbilde", "Zrzut", "Screen"
                    ]
                    
                    let isScreenshot = patterns.contains { name.localizedCaseInsensitiveContains($0) }
                    let isImage = ["png", "jpg", "jpeg", "tiff", "heic"].contains(file.pathExtension.lowercased())
                    
                    guard isScreenshot && isImage else { return false }
                    
                    let values = try? file.resourceValues(forKeys: [.creationDateKey])
                    if let date = values?.creationDate {
                        return now.timeIntervalSince(date) < 15 // Increased window to 15s
                    }
                    return false
                }
                
                for screenshot in screenshots {
                    let alreadyAdded = self.items.contains { item in
                        item.type == .image && item.content == screenshot.lastPathComponent
                    }
                    
                    if !alreadyAdded {
                        if let data = try? Data(contentsOf: screenshot) {
                            self.addItem(content: screenshot.lastPathComponent, type: .image, sourceApp: groupName, imageData: data, filePath: screenshot.path)
                        }
                    }
                }
            } catch {
                print("Error monitoring folder \(url.path): \(error)")
            }
        }
    }
    
    func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            self?.checkClipboard()
        }
    }
    
    func checkClipboard() {
        let pasteboard = NSPasteboard.general
        
        // 1. Hassas veri kontrolü
        let hasSensitiveData = sensitiveTypes.first { pasteboard.types?.contains($0) ?? false } != nil
        if hasSensitiveData { return }
        
        guard pasteboard.changeCount != lastChangeCount else { return }
        lastChangeCount = pasteboard.changeCount
        
        // Handle Images
        if let imageData = pasteboard.data(forType: .tiff) ?? pasteboard.data(forType: .png) {
            let sourceApp = NSWorkspace.shared.frontmostApplication?.localizedName
            addItem(content: "Image Content", type: .image, sourceApp: sourceApp, imageData: imageData)
            return
        }
        
        if let content = pasteboard.string(forType: .string) {
            // Get source application info
            let sourceApp = NSWorkspace.shared.frontmostApplication?.localizedName
            
            if CreditCardUtils.isCreditCard(content) {
                addItem(content: content, type: .creditCard, sourceApp: sourceApp)
            } else {
                addItem(content: content, type: .text, sourceApp: sourceApp)
            }
        }
    }
    
    func addItem(content: String, type: ClipboardContentType, sourceApp: String? = nil, imageData: Data? = nil, filePath: String? = nil) {
        let trimmedContent = content.trimmingCharacters(in: .whitespacesAndNewlines)
        if type != .image && trimmedContent.isEmpty { return }

        DispatchQueue.main.async {
            var wasPinned = false
            // For images, we compare the data if available, or just add it
            if type == .image, let newData = imageData {
                if let existingIndex = self.items.firstIndex(where: { $0.type == .image && ($0.imageData == newData || ($0.filePath != nil && $0.filePath == filePath)) }) {
                    wasPinned = self.items[existingIndex].isPinned
                    self.items.remove(at: existingIndex)
                }
            } else if let existingIndex = self.items.firstIndex(where: { $0.content == trimmedContent && $0.type != .image }) {
                wasPinned = self.items[existingIndex].isPinned
                self.items.remove(at: existingIndex)
            }
            
            let newItem = ClipboardItem(
                content: trimmedContent,
                type: type,
                timestamp: Date(),
                sourceApp: sourceApp,
                isPinned: wasPinned,
                imageData: imageData,
                filePath: filePath
            )
            
            self.items.insert(newItem, at: 0)
            
            // 3. Re-sort to ensure pins stay at top
            self.items.sort { (a, b) in
                if a.isPinned != b.isPinned {
                    return a.isPinned
                }
                return a.timestamp > b.timestamp
            }
            
            // 4. Limit history size
            let historySize = UserDefaults.standard.integer(forKey: "historySize")
            let maxItems = historySize > 0 ? historySize : 50 // Default to 50 if not set
            
            if self.items.count > maxItems {
                self.items.removeLast(self.items.count - maxItems)
            }
            
            self.saveHistory()
            
            // Trigger Advanced AI Processing
            self.processItemAI(newItem.id)
        }
    }
    
    private func processItemAI(_ id: UUID) {
        guard let index = items.firstIndex(where: { $0.id == id }) else { return }
        let item = items[index]
        
        // Skip AI processing for screenshots/file-based images as they usually don't need text analysis immediately
        if item.type == .image && item.filePath != nil {
            return
        }

        items[index].isProcessingAI = true
        
        Task {
            let result = await LLMService.shared.processAdvanced(item)
            
            await MainActor.run {
                if let currentIndex = self.items.firstIndex(where: { $0.id == id }) {
                    self.items[currentIndex].advancedAIResult = result
                    self.items[currentIndex].isProcessingAI = false
                    self.saveHistory()
                }
            }
        }
    }
    
    func performAIAction(_ item: ClipboardItem, action: LLMAction) {
        guard let index = items.firstIndex(where: { $0.id == item.id }) else { return }
        
        items[index].isProcessingAI = true
        
        Task {
            do {
                let result = try await LLMService.shared.process(item.content, action: action)
                await MainActor.run {
                    if let newIndex = self.items.firstIndex(where: { $0.id == item.id }) {
                        self.items[newIndex].aiResult = result
                        self.items[newIndex].isProcessingAI = false
                        self.saveHistory()
                    }
                }
            } catch {
                await MainActor.run {
                    if let newIndex = self.items.firstIndex(where: { $0.id == item.id }) {
                        self.items[newIndex].isProcessingAI = false
                        // Handle error state in UI
                    }
                }
            }
        }
    }
    
    func copyToClipboard(_ item: ClipboardItem) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        
        if item.type == .image, let data = item.imageData {
            // Determine if it's TIFF or PNG
            if let image = NSImage(data: data) {
                if let tiffData = image.tiffRepresentation {
                    pasteboard.setData(tiffData, forType: .tiff)
                }
            }
        } else {
            pasteboard.setString(item.content, forType: .string)
        }
    }
    
    // Kept for backward compatibility if needed, but updated to use the new method
    func copyToClipboard(_ text: String) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(text, forType: .string)
    }
    
    func togglePin(for item: ClipboardItem) {
        guard let index = items.firstIndex(where: { $0.id == item.id }) else { return }
        
        let currentlyPinnedCount = items.filter { $0.isPinned }.count
        
        if !items[index].isPinned && currentlyPinnedCount >= 3 {
            // Optional: Show a notification or alert that max 3 pins are allowed
            return
        }
        
        items[index].isPinned.toggle()
        
        // Re-sort items: Pinned first, then by date
        items.sort { (a, b) in
            if a.isPinned != b.isPinned {
                return a.isPinned
            }
            return a.timestamp > b.timestamp
        }
        saveHistory()
    }
    
    func clearAIResult(for item: ClipboardItem) {
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            items[index].aiResult = nil
            saveHistory()
        }
    }
    
    func removeItem(_ item: ClipboardItem) {
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            items.remove(at: index)
            saveHistory()
        }
    }

    func openFileLocation(for item: ClipboardItem) {
        guard let path = item.filePath else { return }
        let url = URL(fileURLWithPath: path)
        NSWorkspace.shared.activateFileViewerSelecting([url])
    }
    
    func addTag(_ tag: String, to item: ClipboardItem) {
        guard let index = items.firstIndex(where: { $0.id == item.id }) else { return }
        let normalizedTag = tag.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        guard !normalizedTag.isEmpty else { return }
        
        if !items[index].tags.contains(normalizedTag) {
            items[index].tags.append(normalizedTag)
            items[index].tags.sort()
            saveHistory()
            TagManager.shared.addTag(normalizedTag)
        }
    }
    
    func removeTag(_ tag: String, from item: ClipboardItem) {
        guard let index = items.firstIndex(where: { $0.id == item.id }) else { return }
        items[index].tags.removeAll { $0 == tag.lowercased() }
        saveHistory()
    }
    
    func renameTagInAllItems(oldTag: String, newTag: String) {
        for index in items.indices {
            if let tagIndex = items[index].tags.firstIndex(of: oldTag) {
                items[index].tags[tagIndex] = newTag
                items[index].tags.sort()
            }
        }
        saveHistory()
    }

    func clearAllHistory() {
        items.removeAll()
        saveHistory()
    }
}
